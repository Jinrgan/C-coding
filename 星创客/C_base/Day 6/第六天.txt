第六天 算法
1. 排序

2. 查找

练习题
	1. 给定一组数，{1,2,8,9,2,4,9,12,4,7,10,13,6,8,11,15}
		查找这里有没有7，有没有5		
	2. 给定一组数，{18，10，9，8，16，20，38，42，19，50，
		84，72，56，55，76，100，90，88，108}
		查找有没有19， 有没有86
		规律：五五为一组
		第一组最大值18 起始下标0
		第二组最大值50 起始下标5
		第三组最大值84 起始下标10
		第四组最大值108 起始下标15		
		
	4. 有1000桶酒，其中1桶有毒。而一旦吃了，毒性会在1周后发作。现在我们用小老鼠做实验，要在1周内找出那桶毒酒，问最少需要多少老鼠。（写出解题思路）
	5. 微软面试题 
	（1）每个飞机只有一个油箱；
    （2）飞机之间可以相互加油（注意是相互，没有加油机）；　
    （3）一箱油可供一架飞机绕地球飞半圈。那么为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？
 　　
 　　（所有飞机从同一机场起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场）


冒泡排序  /  起泡排序 
	数组中的数，从下标为0开始
	两两进行比较，如果顺序不符合要求，就进行交换
	从小到大
	if (a[0] > a[1])
		swap;
	if (a[1] > a[2])	
		swap;
	if (a[2] > a[3])
		swap;
		....
		
	if (a[N - 2] > a[N - 1])
		swap;	
-----------------for----------------
	for (i = 0  ; i < N - 1; i++)
	{
		if (a[i] > a[i + 1])
			swap;
	}
--------------------------------------	
	以上的这个for循环，执行完这个循环后，只能确定排序后数组中的最大值的位置
	还有N-1个数需要确定位置
	可以把上面的for 执行N次，把数组中所有元素的位置都来确定。
	
	第N - 1次for其实可以确定两个数的位置, 因此，只需要 N-1次的循环
int compareLargeToSmall(int a, int b)
{
	return a < b ? 1 : 0;
}
int compareSmallToLarge(int a, int b)
{
	return a > b ? 1 : 0;
}

void sort(int * arr, int N, int (*pFunc)(int, int))
{
	if (NULL == arr || N <= 0)
	{
		return ;
	}
	int i = 0;
	int j = 0;
	bool flag = TRUE;
	for (j = 0; j < N - 1; j++)
	{
		flag = FALSE;
		for (i = 0; i < N - 1 - j; i++)
		{		
			if (pFunc(arr[i] , arr[i + 1]))		
			{
				swap(&arr[i], &arr[i + 1]);
				flag = TRUE;
			}
		}
		if (FALSE == flag)
			break;
	}
}
	

	
























char * pArray[] = {"China","English", "America", "Franch", "Kerean"};
将pArray中的字符串按字典序排序